# Instructions to analyze the crash:

1. Run the loop executable binary using gdb

```console
gdb ./loop
```

2. With the command-line prompt (gdb), run the application

```console
run
```

3. You can see that the application terminated abnormally due to the runtime exception. Use the backtrace command to review the stack trace

```console
bt
```

4. Let's take a close look at frame 6, since this is the function that throws the exception

```console
frame 6
```

5. Run the list command to see the nearby code

```console
list
```

6. Run the info locals command to see the start, end, and delta variables
```console
info locals
```

7. Use the info args command to see the limit value
```console
info args
```

# Working with breakpoints

1. Run the loop executable binary using gdb

```console
gdb ./loop
```

2. For debugger the function runner, enter with the following command. This will show the code between the function `runner` and the first line of the function `delay_ms`.

```console
list runner,delay_ms
```

3. Check the number of the line equivalent to `if (delta > limit)` and use with the break command, for example.

```console
break 15
```

4. And run the program

```console
run
```

5. When the program pause, check the value of `delta`

```console
print delta
```

6. Continue execution of the program by typing continue, or just c

```console
c
```

7. Check the value of `delta` by press `c` command. the better way is using the `command` to automatize this commands. Press command

```console
command
```

Enter with the information as below
```console
(gdb) command
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
>silent
>printf "delta=%d, expected=%d\n", delta.__r, value
>end
(gdb) c
```

# Working with core dumps


1. Run the `ulimit -c` command to check the current status. Zero means no core dumps. 

2. Run the `ulimit -c unlimited` command to allow core dumps of any size. If necessary, run the command as root privilege.

```console
ulimit -c unlimited
```

3. Make sure that the limit was changed. Maybe will be necessary do the logout. The expected result is
```
$ ulimit -c
unlimited
```

4. Run the application

```console
./loop
```

5. It will crash with an exception. Run the ls command to check whether a core file was created in the current directory.

6. Now, run gdb, passing the executable and the core files as parameters

```console
gdb ./loop core
```

7. The followin message will be show. Press `c` to continue
```
[New LWP 2632]
--Type <RET> for more, q to quit, c to continue without paging--
```

8. In the GDB shell, run the bt command to see the stack trace
```console
bt
```

9. You can see the same stack trace as for the application running from inside gdb. However, in this case, we see the stack trace of the core dump.


# Important Note: 
- To use the full capabilities of the GDB, the application should be built with debug symbol support. 
- Creation of core files in every case is not practical. 
- Core files can account for megabytes or even gigabytes on a filesystem.
- Developers need to explicitly specify the maximum size of the core files that are allowed to be generated by the operating system. 


# Remote debugging

1. Install gdb-multiarch on host

```console
sudo apt-get install gdb-multiarch
```

2. Install gdbserver on Raspberry Pi

```console
sudo apt-get install gdbserver
```

3. Inside the target run the hello application under gdbserver

```console
gdbserver 0.0.0.0:9090 ./hello
```

4. Inside the build system terminal acess the hello folder and run the command, passing the application binary as a parameter

```console
gdb-multiarch -q hello
```

5. Configure a remote connection by typing the following command in the GDB command line

```console
target remote X.X.X.X:9090
```

6. Type the continue command

```console
continue
```

# Adding debug logging

Logging itself introduces certain delays. Firstly, it takes time to format the log messages and put them into the log stream. Secondly, the log stream should be reliably stored in persistent storage, such as a flash card or a disk drive, or sent to the remote system. 